local fs = require("@lune/fs")
local roblox = require("@lune/roblox")
local net = require("@lune/net")
local serde = require("@lune/serde")

-- 1. CONFIGURA√á√ïES
local outputFolder = "Game"
local inputFileName = "Place.rbxl" 
local API_URL = "https://raw.githubusercontent.com/CloneTrooper1019/Roblox-Client-Tracker/roblox/API-Dump.json"

local ScriptExtensions = {
    ["ModuleScript"] = ".module.luau",
    ["Script"]       = ".server.luau",
    ["LocalScript"]  = ".client.luau"
}

-- 2. PREPARA√á√ÉO
local RobloxClasses = {}
local response = net.request({ url = API_URL, method = "GET" })
if response.ok then
    local data = serde.decode("json", response.body)
    for _, classDef in ipairs(data.Classes) do RobloxClasses[classDef.Name] = classDef end
end

if fs.isDir(outputFolder) then fs.removeDir(outputFolder) end
fs.writeDir(outputFolder)

-- 3. FUN√á√ïES AUXILIARES
local function Sanitize(name)
    return name:gsub("[\\/:*?\"<>|]", "_")
end

local function CleanSource(code)
    local s = code:find("<string name=\"Source\">")
    if not s then return code end
    s = s + 22
    local e = code:find("</string>", s) or -1
    return code:sub(s, e - 1):gsub("&lt;", "<"):gsub("&gt;", ">"):gsub("&amp;", "&"):gsub("&quot;", '"'):gsub("&apos;", "'"):gsub("<!%[CDATA%[", ""):gsub("%]%]>", "")
end

-- 4. ESCREVE ARQUIVO (Itens sem filhos)
local function WriteItem(instance, path)
    local name = Sanitize(instance.Name)
    local ext = ScriptExtensions[instance.ClassName]
    local fileName, content

    local suffix = "." .. instance.ClassName:lower()

    if ext then
        fileName = name .. ext
        content = CleanSource(roblox.serializeModel({instance}, true))
    else
        -- Se for Folder sem filhos, n√£o precisa do sufixo .folder no arquivo tamb√©m, 
        -- mas como √© um arquivo placeholder, vamos manter pra saber o tipo, ou tirar se preferir.
        -- Vou manter no arquivo solto pra diferenciar de arquivo sem extens√£o.
        fileName = name .. suffix .. ".rbxmx"
        content = "PLACEHOLDER\nType: " .. instance.ClassName
    end

    fs.writeFile(path .. "/" .. fileName, content)
end

-- 5. L√ìGICA DE PASTAS (AQUI EST√Å A MUDAN√áA)
local function ProcessNode(instance, currentPath)
    local children = instance:GetChildren()
    local name = Sanitize(instance.Name)

    if #children > 0 then
        -- Define o nome da pasta
        local folderName
        
        if instance.ClassName == "Folder" then
            -- Se J√Å √â uma Folder, usa s√≥ o nome (Ex: "AssetsItems")
            folderName = name
        else
            -- Se √© outra coisa (ScreenGui, Frame), usa o sufixo (Ex: "CombateUI.screengui")
            folderName = name .. "." .. instance.ClassName:lower()
        end
        
        local newPath = currentPath .. "/" .. folderName
        
        if not fs.isDir(newPath) then fs.writeDir(newPath) end

        -- Se for Folder normal, n√£o precisamos salvar o arquivo "pai" dentro dela,
        -- pois a pasta j√° representa a Folder.
        -- Mas se for um objeto especial (ScreenGui), precisamos do arquivo placeholder dentro?
        -- Na vers√£o anterior removemos para limpar. Mantemos assim.
        
        -- Nota: Se o objeto tiver atributos/tags importantes, n√£o salvar o arquivo pai 
        -- significa perder esses dados na visualiza√ß√£o.
        -- Mas para visualiza√ß√£o de c√≥digo, t√° limpo assim.

        for _, child in ipairs(children) do
            ProcessNode(child, newPath)
        end
    else
        WriteItem(instance, currentPath)
    end
end

-- 6. RODAR
local parsedFile = fs.readFile(inputFileName)
local game = roblox.deserializePlace(parsedFile)

local Services = {"ReplicatedFirst", "ReplicatedStorage", "ServerScriptService", "ServerStorage", "StarterGui", "StarterPack", "StarterPlayer", "Workspace"}

for _, sName in ipairs(Services) do
    local service = game:GetService(sName)
    if service then
        print("üì¶ Exportando " .. sName)
        local sPath = outputFolder .. "/" .. sName
        fs.writeDir(sPath)
        for _, child in ipairs(service:GetChildren()) do
            ProcessNode(child, sPath)
        end
    end
end

print("‚úÖ Exporta√ß√£o (Sem .folder redundante) Conclu√≠da!")