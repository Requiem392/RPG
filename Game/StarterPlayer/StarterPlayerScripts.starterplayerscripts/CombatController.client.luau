local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")
local Animator = Humanoid:WaitForChild("Animator")

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local CombatRemote = Remotes:WaitForChild("CombatAction")
local CombatStateRemote = Remotes:WaitForChild("CombatState")

-- M√≥dulos
local RaycastHitbox = require(ReplicatedStorage:WaitForChild("RaycastHitboxV4"))
local DataFolder = ReplicatedStorage:WaitForChild("Data")
local ItemData = require(DataFolder:WaitForChild("ItemData"))
local TrailManager = require(ReplicatedStorage:WaitForChild("TrailManager"))
local ResourceManager = require(ReplicatedStorage:WaitForChild("ResourceManager"))
local DefenseManager = require(ReplicatedStorage:WaitForChild("DefenseManager"))

-- Resource Remotes
local ResourceRequest = Remotes:WaitForChild("ResourceRequest")

-- Defense Remotes
local DefenseEvent = Remotes:WaitForChild("DefenseAction")
local DefenseRequest = Remotes:WaitForChild("DefenseRequest")

-- Configura√ß√µes
local DASH_FORCE = 20
local DASH_RANGE = 6 -- Distancia pra checar inimigo
local DASH_WIDTH = 3 -- Largura do leque de detec√ß√£o

-- Estado de Combate
local LastSwingSide = "Right" -- Come√ßa com Right para pr√≥ximo ataque ser Left
local IsAttacking = false
local LoadedAnims = {}
local CurrentWeaponCategory = nil
local SoundCache = {}
local IdleTrack = nil -- Track da anima√ß√£o Idle
local PlayerHitbox = nil -- Hitbox local do cliente
local HitCooldowns = {} -- Anti-spam: {[target] = lastHitTime}

-- Estado Defensivo
local IsBlocking = false
local IsParrying = false
local IsStunned = false
local BlockDrainConnection = nil

-- Vari√°veis para lock de movimento no stun
local OriginalWalkSpeed = 16
local OriginalJumpPower = 50
local StunExpirationTime = 0

-- Estado de Feint
local AttackStartTime = 0
local CanFeint = false
local LastFeintTime = 0

local FEINT_CONFIG = {
	Window = 0.6,     -- Janela para feint (segundos) - AUMENTADA
	Cost = 5,         -- Custo de energia
	Cooldown = 1.0,   -- Cooldown entre feints
	AnimSpeed = 0.5   -- Velocidade das anima√ß√µes (70% = mais lento)
}

-- === FUN√á√ïES AUXILIARES ===

-- Carrega anima√ß√µes baseadas na categoria da arma equipada
local function LoadAnimations(weaponCategory, weaponItemInfo)
	if not weaponCategory then return end

	-- Limpa anima√ß√µes antigas
	for _, track in pairs(LoadedAnims) do
		if track then
			track:Stop()
			track:Destroy()
		end
	end
	LoadedAnims = {}

	-- Para e limpa idle track anterior
	if IdleTrack then
		IdleTrack:Stop()
		IdleTrack:Destroy()
		IdleTrack = nil
	end

	-- Carrega novas anima√ß√µes da categoria
	local categoryData = ItemData.GetCategory(weaponCategory)
	if not categoryData then 
		warn("[CombatController] Categoria n√£o encontrada:", weaponCategory)
		return 
	end

	-- === SISTEMA DE MERGE DE ANIMA√á√ïES ===
	-- 1. Come√ßa com anima√ß√µes da categoria (base)
	-- 2. Sobrescreve com anima√ß√µes espec√≠ficas da arma (se existirem)

	local finalAnimations = {}

	-- Copia anima√ß√µes da categoria
	for name, id in pairs(categoryData.Animations) do
		if id then
			finalAnimations[name] = id
		end
	end

	-- Sobrescreve com anima√ß√µes espec√≠ficas da arma (se existir)
	if weaponItemInfo and weaponItemInfo.Animations then
		for name, id in pairs(weaponItemInfo.Animations) do
			if id then -- S√≥ sobrescreve se n√£o for nil
				finalAnimations[name] = id
				print("‚ú® [Override] Usando anima√ß√£o customizada:", name, "da arma", weaponItemInfo.Name)
			end
		end
	end

	-- Carrega anima√ß√µes finais (j√° com overrides aplicados)
	for name, id in pairs(finalAnimations) do
		local anim = Instance.new("Animation")
		anim.AnimationId = id
		local track = Animator:LoadAnimation(anim)

		-- Configura prioridades
		if name == "Idle" then
			track.Priority = Enum.AnimationPriority.Action -- Idle elevada
			IdleTrack = track
		else
			track.Priority = Enum.AnimationPriority.Action2 -- Ataques precisam ser maior que Idle
		end

		LoadedAnims[name] = track
	end

	CurrentWeaponCategory = weaponCategory
	print("‚öîÔ∏è Anima√ß√µes carregadas para categoria:", weaponCategory)
end

-- Carrega sons da categoria
local function LoadSounds(weaponCategory)
	SoundCache = {}

	if not weaponCategory then return end

	local categoryData = ItemData.GetCategory(weaponCategory)
	if not categoryData or not categoryData.Sounds then return end

	for soundName, soundId in pairs(categoryData.Sounds) do
		local sound = Instance.new("Sound")
		sound.SoundId = soundId
		sound.Volume = 0.5
		sound.Parent = RootPart
		SoundCache[soundName] = sound
	end
end

-- Toca um som
local function PlaySound(soundName)
	local sound = SoundCache[soundName]
	if sound then
		sound:Play()
	end
end

-- === SISTEMA DE HITBOX CLIENT-SIDE ===

-- Configura hitbox local
local function SetupLocalHitbox(weapon)
	if PlayerHitbox then
		-- Verifica se √© um objeto v√°lido com m√©todo Destroy
		if type(PlayerHitbox) == "table" and PlayerHitbox.Destroy then
			pcall(function() PlayerHitbox:Destroy() end)
		end
		PlayerHitbox = nil
	end

	if not weapon then return end

	print("‚öîÔ∏è [CombatController] Configurando Hitbox local")

	-- Cria hitbox local
	local hitbox = RaycastHitbox.new(weapon)
	hitbox.RaycastParams = RaycastParams.new()
	hitbox.RaycastParams.FilterDescendantsInstances = {Character}
	hitbox.RaycastParams.FilterType = Enum.RaycastFilterType.Exclude

	-- Callback quando acerta algo
	hitbox.OnHit:Connect(function(hit, humanoid)
		if not humanoid or humanoid.Health <= 0 then return end

		local targetChar = humanoid.Parent
		local now = tick()

		-- Anti-spam: cooldown de 0.1s por alvo
		if HitCooldowns[targetChar] and (now - HitCooldowns[targetChar]) < 0.1 then
			return
		end
		HitCooldowns[targetChar] = now

		print("üéØ [CombatController] Hit detectado:", targetChar.Name)

		-- Envia para servidor validar e aplicar dano
		CombatRemote:FireServer("RegisterHit", targetChar, hit.Position)
	end)

	PlayerHitbox = hitbox
end

-- Limpa hitbox local
local function CleanupLocalHitbox()
	if PlayerHitbox then
		-- Verifica se √© um objeto v√°lido com m√©todo Destroy
		if type(PlayerHitbox) == "table" and PlayerHitbox.Destroy then
			pcall(function() PlayerHitbox:Destroy() end)
			print("üóëÔ∏è [CombatController] Hitbox local removida")
		end
		PlayerHitbox = nil
	end
	HitCooldowns = {}
end

local function SmartDash()
	-- "Linhas Inteligentes" (L√≥gica portada do AnimaCombate)
	local origin = RootPart.CFrame
	local foundEnemy = false

	-- Visual Folder
	local visualFolder = workspace:FindFirstChild("VisualCombate") or Instance.new("Folder", workspace)
	visualFolder.Name = "VisualCombate"

	-- Par√¢metros do Raycast
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {Character, visualFolder}
	params.FilterType = Enum.RaycastFilterType.Exclude

	-- Leque de 5 linhas
	for i = 0, 4 do
		local offset = -DASH_WIDTH/2 + (DASH_WIDTH/4 * i)
		local startPosCFrame = origin * CFrame.new(offset, 0, 0)
		local startPos = startPosCFrame.Position
		local direction = origin.LookVector * DASH_RANGE

		local result = workspace:Raycast(startPos, direction, params)
		local dist = DASH_RANGE
		local color = Color3.fromRGB(255, 0, 0) -- Vermelho (Livre)

		if result then
			dist = result.Distance
			if result.Instance.Parent:FindFirstChild("Humanoid") then
				foundEnemy = true
				color = Color3.fromRGB(0, 255, 0) -- Verde (Inimigo)
			end
		end

		-- DEBUG VISUAL
		local line = Instance.new("Part")
		line.Size = Vector3.new(0.05, 0.05, dist)
		line.CFrame = CFrame.lookAt(startPos, startPos + direction) * CFrame.new(0, 0, -dist/2)
		line.Anchored = true
		line.CanCollide = false
		line.Material = Enum.Material.Neon
		line.Color = color
		line.Transparency = 0.5
		line.Parent = visualFolder
		Debris:AddItem(line, 0.5)
	end

	if not foundEnemy then
		local bv = Instance.new("BodyVelocity")
		bv.Velocity = RootPart.CFrame.LookVector * DASH_FORCE
		bv.MaxForce = Vector3.new(100000, 0, 100000)
		bv.Parent = RootPart
		Debris:AddItem(bv, 0.2)
	end
end

local function GetEquippedWeapon()
	-- Procura por um modelo de arma no personagem
	for _, child in pairs(Character:GetChildren()) do
		if child:IsA("Model") and child:FindFirstChild("Hitbox") then
			return child
		end
	end
	return nil
end

-- Obt√©m informa√ß√µes da arma equipada
local function GetWeaponInfo()
	local weapon = GetEquippedWeapon()
	if not weapon then return nil, nil end

	local weaponName = string.gsub(weapon.Name, "Equipped_", "")
	local itemInfo = ItemData.Get(weaponName)

	return weapon, itemInfo
end

-- === SISTEMA DEFENSIVO ===

-- Inicia bloqueio
local function StartBlock()
	-- N√£o pode bloquear durante ataque
	if IsAttacking then
		print("‚ö†Ô∏è N√£o pode bloquear durante ataque!")
		return
	end

	-- Verifica se est√° stunned
	local stunned = DefenseRequest:InvokeServer("IsStunned")
	if stunned then 
		print("‚ö†Ô∏è N√£o pode bloquear enquanto stunned!")
		return 
	end

	if IsBlocking then return end

	-- Verifica energia m√≠nima
	local currentStamina = ResourceRequest:InvokeServer("GetStamina")
	if currentStamina < 5 then
		print("‚ö†Ô∏è Sem energia para bloquear!")
		return
	end

	IsBlocking = true
	CombatStateRemote:FireServer("Blocking", true) -- Notifica servidor
	DefenseEvent:FireServer("StartBlock")

	-- Toca anima√ß√£o de bloqueio
	local blockTrack = LoadedAnims["Block"]
	if blockTrack then
		blockTrack.Looped = true
		blockTrack:Play(0.1) -- Fade in 0.1s
		print("üõ°Ô∏è Bloqueio ativado")
	else
		print("üõ°Ô∏è Bloqueio ativado (sem anima√ß√£o)")
	end
end

-- Para bloqueio
local function StopBlock()
	if not IsBlocking then return end

	IsBlocking = false
	CombatStateRemote:FireServer("Blocking", false) -- Notifica servidor
	DefenseEvent:FireServer("StopBlock")

	-- Para anima√ß√£o de bloqueio
	local blockTrack = LoadedAnims["Block"]
	if blockTrack and blockTrack.IsPlaying then
		blockTrack:Stop(0.1) -- Fade out 0.1s
	end

	print("üõ°Ô∏è Bloqueio desativado")

	-- TODO: Sair da anima√ß√£o de block
end

-- Tenta parry
local function AttemptParry()
	-- N√£o pode parry durante ataque
	if IsAttacking then
		print("‚ö†Ô∏è N√£o pode parry durante ataque!")
		return
	end

	-- Previne spam de parry
	if IsParrying then
		print("‚ö†Ô∏è Parry j√° est√° ativo!")
		return
	end

	-- Verifica se est√° stunned
	local stunned = DefenseRequest:InvokeServer("IsStunned")
	if stunned then 
		print("‚ö†Ô∏è N√£o pode parry enquanto stunned!")
		return 
	end

	-- Verifica se pode parry (cooldown, etc)
	local canParry = DefenseRequest:InvokeServer("CanParry")
	if not canParry then
		print("‚ö†Ô∏è Parry em cooldown!")
		return
	end

	-- Verifica energia
	local config = DefenseManager.GetConfig()
	local hasEnergy = ResourceRequest:InvokeServer("UseStamina", config.Parry.Cost)

	if not hasEnergy then
		print("‚ö†Ô∏è Sem energia para parry!")
		return
	end

	-- Ativa parry
	IsParrying = true
	DefenseEvent:FireServer("StartParry")

	-- Toca anima√ß√£o de parry
	local parryTrack = LoadedAnims["Parry"]
	if parryTrack then
		parryTrack:Play(0.05) -- Fade in r√°pido
		-- Para anima√ß√£o automaticamente ap√≥s a janela de parry
		task.delay(config.Parry.Window, function()
			if parryTrack.IsPlaying then
				parryTrack:Stop(0.1)
			end
			IsParrying = false -- Libera para novo parry
		end)
		print("‚öîÔ∏è Parry ativado! Janela de", config.Parry.Window, "segundos")
	else
		IsParrying = false
		print("‚öîÔ∏è Parry ativado! Janela de", config.Parry.Window, "segundos")
	end
end

-- === SISTEMA DE ATAQUE ===

local function Attack()
	local weapon, itemInfo = GetWeaponInfo()
	if not weapon or IsAttacking or IsBlocking then return end

	-- MARCA COMO ATACANDO IMEDIATAMENTE (antes de qualquer coisa)
	IsAttacking = true
	Character:SetAttribute("IsAttacking", true) -- Para PostureHandler detectar
	CombatStateRemote:FireServer("Attacking", true)

	-- Verifica se est√° stunned
	local stunned = DefenseRequest:InvokeServer("IsStunned")
	if stunned then 
		print("‚ö†Ô∏è N√£o pode atacar enquanto stunned!")
		IsAttacking = false -- Reseta se n√£o pode atacar
		CombatStateRemote:FireServer("Attacking", false)
		return 
	end

	-- Pega dados da categoria
	local categoryData = ItemData.GetCategory(itemInfo.WeaponCategory)
	if not categoryData then 
		IsAttacking = false
		CombatStateRemote:FireServer("Attacking", false)
		return 
	end

	-- >>> VERIFICA E GASTA ENERGIA <<<
	local config = ResourceManager.GetConfig()
	local energyCost = config.Stamina.AttackCost

	-- Verifica com o servidor se tem energia (valida√ß√£o autoritativa)
	local hasEnergy = ResourceRequest:InvokeServer("UseStamina", energyCost)

	if not hasEnergy then
		-- Sem energia, n√£o ataca
		print("‚ö†Ô∏è Sem energia para atacar!")
		IsAttacking = false
		CombatStateRemote:FireServer("Attacking", false)
		return
	end

	-- === ATIVA JANELA DE FEINT ===
	AttackStartTime = tick()
	CanFeint = true

	-- Desativa feint ap√≥s janela
	task.delay(FEINT_CONFIG.Window, function()
		CanFeint = false
	end)

	-- === ALTERN√ÇNCIA DE LADOS ===
	-- Alterna entre SwingLeft e SwingRight independente do tempo
	local animName = LastSwingSide == "Right" and "SwingLeft" or "SwingRight"
	LastSwingSide = LastSwingSide == "Right" and "Left" or "Right"

	-- Motor6D: Usa apenas RightArmMotor para ambos os swings (simplificado)
	-- As novas anima√ß√µes v√£o usar o mesmo motor mas com cortes diferentes

	local track = LoadedAnims[animName]

	if track then
		-- >>> ATIVA TRAIL <<<
		if itemInfo.TrailEnabled then
			TrailManager.ActivateTrailForDuration(weapon, categoryData.TrailDuration or 0.3)
		end

		-- Toca anima√ß√£o com velocidade normal
		track:Play()

		-- Conecta ao evento Start para iniciar hitbox LOCAL e dash
		local startConnection
		startConnection = track:GetMarkerReachedSignal("Start"):Connect(function()
			print("üó°Ô∏è Hitbox ATIVADA (evento Start)")

			-- Som de swing (sincronizado)
			PlaySound("Swing")

			-- Dash inteligente (sincronizado com hitbox)
			SmartDash()

			if PlayerHitbox and PlayerHitbox.HitStart then
				PlayerHitbox:HitStart()
			end
			startConnection:Disconnect()
		end)

		-- Conecta ao evento End para parar hitbox
		local endConnection
		endConnection = track:GetMarkerReachedSignal("End"):Connect(function()
			print("üõ°Ô∏è Hitbox DESATIVADA (evento End)")
			-- Para hitbox LOCAL
			if PlayerHitbox and PlayerHitbox.HitStop then
				PlayerHitbox:HitStop()
			end
			endConnection:Disconnect()
		end)


		-- Fallback: se a anima√ß√£o terminar sem disparar o evento End
		track.Stopped:Connect(function()
			if IsAttacking then
				print("‚ö†Ô∏è Anima√ß√£o parou sem evento End, resetando...")
				if PlayerHitbox and PlayerHitbox.HitStop then
					PlayerHitbox:HitStop()
				end

				-- (RightArmMotor j√° deve estar ativo)

				if IdleTrack and not IdleTrack.IsPlaying then
					IdleTrack:Play(0.5)
				end
				IsAttacking = false
				Character:SetAttribute("IsAttacking", false) -- Reset para PostureHandler
				CombatStateRemote:FireServer("Attacking", false)
			end
		end)
	end
end

-- ============================================================================
-- SISTEMA DE FEINT
-- ============================================================================

-- Verifica se est√° na janela de feint
local function InFeintWindow()
	if not IsAttacking then return false end
	if not CanFeint then return false end

	local elapsed = tick() - AttackStartTime
	return elapsed <= FEINT_CONFIG.Window
end

-- Executa feint (cancela ataque)
function ExecuteFeint()
	-- Verifica cooldown
	local now = tick()
	if now - LastFeintTime < FEINT_CONFIG.Cooldown then
		print("‚ö†Ô∏è Feint em cooldown!")
		return false
	end

	-- Verifica janela
	if not InFeintWindow() then
		print("‚ö†Ô∏è Fora da janela de feint! (primeiros 0.6s)")
		return false
	end

	-- Verifica energia
	local hasEnergy = ResourceRequest:InvokeServer("UseStamina", FEINT_CONFIG.Cost)
	if not hasEnergy then
		print("‚ö†Ô∏è Sem energia para feint!")
		return false
	end

	print("‚ú® FEINT! Ataque cancelado")

	-- Para anima√ß√£o atual
	for _, track in pairs(LoadedAnims) do
		if track.IsPlaying and track ~= IdleTrack then
			track:Stop()
		end
	end

	-- Para hitbox se estava ativa
	if PlayerHitbox then
		PlayerHitbox:HitStop()
	end

	-- (RightArmMotor j√° deve estar ativo)
	print("üîÑ Feint: RightArmMotor mantido")

	-- Toca anima√ß√£o Idle customizada
	if IdleTrack and not IdleTrack.IsPlaying then
		IdleTrack:Play()
		print("üé≠ Feint: Voltou para Idle customizada")
	end

	-- Reseta estados
	IsAttacking = false
	CanFeint = false
	LastFeintTime = now
	CombatStateRemote:FireServer("Attacking", false) -- Notifica servidor

	-- Notifica servidor
	CombatRemote:FireServer("Feint")

	return true
end

-- Input
local ToggleRemote = Remotes:WaitForChild("ToggleCombat")
local IsCombatMode = false
local ToggleDebounce = false

-- Atualiza categoria quando trocar de arma
local function UpdateWeaponCategory()
	local weapon, itemInfo = GetWeaponInfo()
	if itemInfo and itemInfo.WeaponCategory then
		if itemInfo.WeaponCategory ~= CurrentWeaponCategory then
			LoadAnimations(itemInfo.WeaponCategory, itemInfo) -- Passa itemInfo para merge
			LoadSounds(itemInfo.WeaponCategory)
		end
		-- Setup hitbox local
		SetupLocalHitbox(weapon)
	end
end

local function GetWeaponName()
	-- Tenta achar arma na m√£o ou costas
	for _, child in pairs(Character:GetChildren()) do
		if child:IsA("Model") and (child:FindFirstChild("Hitbox") or child.Name:find("Equipped_")) then
			return string.gsub(child.Name, "Equipped_", "")
		end
	end
	return nil
end

local function GetAnimLength(animId)
	if not animId then return 0.5 end 
	-- Carrega rapidinho s√≥ pra ler o tamanho, se n√£o tiver cahced
	local anim = Instance.new("Animation")
	anim.AnimationId = animId
	local track = Animator:LoadAnimation(anim)
	local length = track.Length
	-- track:Destroy() -- Opcional, mas tracks se limpam
	if length == 0 then return 1 else return length end
end

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	-- [T] Sacar / Guardar Arma
	if input.KeyCode == Enum.KeyCode.T then
		if ToggleDebounce then return end

		-- Bloqueia toggle durante ataque ou bloqueio
		if IsAttacking then
			print("‚ö†Ô∏è N√£o pode equipar/desequipar enquanto ataca!")
			return
		end

		-- Verifica√ß√£o adicional: checa se anima√ß√µes de ataque est√£o tocando
		if LoadedAnims["SwingLeft"] and LoadedAnims["SwingLeft"].IsPlaying then
			print("‚ö†Ô∏è Aguarde o ataque terminar!")
			return
		end

		if LoadedAnims["SwingRight"] and LoadedAnims["SwingRight"].IsPlaying then
			print("‚ö†Ô∏è Aguarde o ataque terminar!")
			return
		end

		if IsBlocking then
			print("‚ö†Ô∏è N√£o pode equipar/desequipar enquanto bloqueia!")
			return
		end

		local weaponName = GetWeaponName()
		if not weaponName then return end

		local itemInfo = ItemData.Get(weaponName)
		if not itemInfo then return end

		-- Busca anima√ß√£o de Equip/Unequip (pode vir da categoria)
		local targetAnimId
		if IsCombatMode then
			-- Desequipar: busca Unequip
			if itemInfo.Animations and itemInfo.Animations.Unequip then
				targetAnimId = itemInfo.Animations.Unequip
			else
				local categoryData = ItemData.GetCategory(itemInfo.WeaponCategory)
				if categoryData and categoryData.Animations then
					targetAnimId = categoryData.Animations.Unequip
				end
			end
		else
			-- Equipar: busca Equip
			if itemInfo.Animations and itemInfo.Animations.Equip then
				targetAnimId = itemInfo.Animations.Equip
			else
				local categoryData = ItemData.GetCategory(itemInfo.WeaponCategory)
				if categoryData and categoryData.Animations then
					targetAnimId = categoryData.Animations.Equip
				end
			end
		end

		local cooldown = GetAnimLength(targetAnimId)

		ToggleDebounce = true
		local wasCombatMode = IsCombatMode
		IsCombatMode = not IsCombatMode
		ToggleRemote:FireServer()

		-- Carrega anima√ß√µes da categoria quando equipar
		if IsCombatMode then
			UpdateWeaponCategory()

			-- Inicia anima√ß√£o Idle com delay calculado para overlap suave
			-- Come√ßa 0.15s antes da anima√ß√£o de equipar terminar para fazer um crossfade
			local delayTime = math.max(0, cooldown - 0.15)

			task.delay(delayTime, function()
				if IsCombatMode and IdleTrack then
					IdleTrack:Play(0.3) -- Fade de 0.3s para blend suave
					print("‚öîÔ∏è Modo de Combate! Idle ativa.")
				end
			end)

			print("‚öîÔ∏è Sacando arma... (CD: " .. string.format("%.2f", cooldown) .. "s)")
		else
			-- Para anima√ß√£o Idle
			if IdleTrack and IdleTrack.IsPlaying then
				IdleTrack:Stop()
			end
			-- Limpa hitbox local
			CleanupLocalHitbox()
			-- Desativa qualquer trail ativo ao desequipar
			local weapon = GetEquippedWeapon()
			if weapon then
				TrailManager.DisableTrail(weapon)
			end
			print("üïäÔ∏è Modo Pac√≠fico... (CD: " .. string.format("%.2f", cooldown) .. "s)")
		end

		task.wait(cooldown)
		ToggleDebounce = false
	end

	-- [LMB] Ataque
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		if IsCombatMode and not ToggleDebounce then
			Attack()
		end
	end

	-- [RMB] Block (segurar)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		if IsCombatMode then
			StartBlock()
		end
	end

	-- [F] Parry
	if input.KeyCode == Enum.KeyCode.F then
		if IsCombatMode then
			AttemptParry()
		end
	end

	-- [E] Feint (cancelar ataque)
	if input.KeyCode == Enum.KeyCode.E then
		ExecuteFeint()
	end
end)

-- Input Ended (soltar bot√µes)
UserInputService.InputEnded:Connect(function(input, gp)
	if gp then return end

	-- [RMB] Soltar Block
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		StopBlock()
	end
end)

-- Inicializa√ß√£o
Player.CharacterAdded:Connect(function(newChar)
	Character = newChar
	Humanoid = newChar:WaitForChild("Humanoid")
	RootPart = newChar:WaitForChild("HumanoidRootPart")
	Animator = Humanoid:WaitForChild("Animator")

	-- Limpa trails e hitbox do personagem anterior
	TrailManager.CleanupAll()
	CleanupLocalHitbox()
end)

-- Carrega arma inicial se j√° estiver equipada
task.wait(1) -- Aguarda invent√°rio carregar
UpdateWeaponCategory()

-- Sistema de dreno de energia durante Block
local lastDrainTime = tick()
RunService.Heartbeat:Connect(function()
	if IsBlocking then
		local now = tick()
		local deltaTime = now - lastDrainTime
		lastDrainTime = now

		-- Calcula dreno (5 energia/segundo)
		local config = DefenseManager.GetConfig()
		local drainAmount = config.Block.DrainPerSecond * deltaTime

		-- Verifica se tem energia
		local currentStamina = ResourceRequest:InvokeServer("GetStamina")

		if currentStamina < drainAmount then
			-- Energia acabou, para o block
			StopBlock()
			print("‚ö†Ô∏è Energia esgotada! Bloqueio desativado.")
		else
			-- Drena energia
			ResourceRequest:InvokeServer("UseStamina", drainAmount)
		end
	else
		lastDrainTime = tick()
	end
end)

-- Monitora quando arma √© equipada/desequipada
Character.ChildAdded:Connect(function(child)
	if child:IsA("Model") and child:FindFirstChild("Hitbox") then
		print("üîç [DEBUG] Arma detectada:", child.Name)

		-- Arma equipada, espera um frame para garantir que est√° configurada
		task.wait(0.1)
		UpdateWeaponCategory()

		-- SINCRONIZA IsCombatMode com estado real
		local handle = child:FindFirstChild("Handle")
		if handle then
			-- Verifica se j√° tem Motor6D (arma j√° sacada)
			if handle:FindFirstChild("RightArmMotor") then
				IsCombatMode = true
				print("üîç [DEBUG] Motor6D J√Å EXISTE ‚Üí IsCombatMode = TRUE")
			else
				IsCombatMode = false
				print("üîç [DEBUG] Sem Motor6D ‚Üí IsCombatMode = FALSE")
			end

			-- Listener para detectar quando Motor6D √© criado (DrawWeapon)
			local motorConnection
			motorConnection = handle.ChildAdded:Connect(function(motor)
				if motor.Name == "RightArmMotor" then
					-- Motor6D criado, arma foi sacada
					IsCombatMode = true
					print("üîç [DEBUG] Motor6D CRIADO ‚Üí IsCombatMode = TRUE")

					task.delay(0.1, function()
						if IdleTrack and not IdleTrack.IsPlaying then
							IdleTrack:Play(0.3)
						end
					end)
					motorConnection:Disconnect()
				end
			end)

			-- Fallback: verifica se Motor6D foi criado antes do listener
			task.delay(1.5, function()
				if handle.Parent and handle:FindFirstChild("RightArmMotor") then
					if not IsCombatMode then
						IsCombatMode = true
						print("üîç [DEBUG FALLBACK] Motor6D detectado ‚Üí IsCombatMode = TRUE")
						if IdleTrack and not IdleTrack.IsPlaying then
							IdleTrack:Play(0.3)
						end
					end
				end
				motorConnection:Disconnect()
			end)
		end
	end
end)

Character.ChildRemoved:Connect(function(child)
	-- Detecta arma removida pelo nome ao inv√©s de Hitbox (pode j√° ter sido destru√≠do)
	if child:IsA("Model") and child.Name:match("^Equipped_") then
		print("üóëÔ∏è [ChildRemoved] Arma removida:", child.Name)

		-- Arma removida, limpa anima√ß√µes
		for _, track in pairs(LoadedAnims) do
			if track then
				track:Stop()
				track:Destroy()
			end
		end
		LoadedAnims = {}

		if IdleTrack then
			IdleTrack:Stop()
			IdleTrack:Destroy()
			IdleTrack = nil
		end

		-- Reseta estado de combate
		if IsCombatMode then
			IsCombatMode = false
		end

		CurrentWeaponCategory = nil
		CleanupLocalHitbox()
	end
end)

-- Verifica se j√° tem arma equipada ao iniciar
task.wait(0.5)
UpdateWeaponCategory()

-- === LISTENER DE EVENTOS DEFENSIVOS ===

DefenseEvent.OnClientEvent:Connect(function(action, data)
	if action == "StunApplied" then
		-- Toca anima√ß√£o de stun
		local stunAnim = Instance.new("Animation")
		stunAnim.AnimationId = "rbxassetid://91996512144744"
		local stunTrack = Animator:LoadAnimation(stunAnim)
		stunTrack.Priority = Enum.AnimationPriority.Action4 -- M√°xima prioridade

		-- TRAVA MOVIMENTO e PULO
		if not IsStunned then
			OriginalWalkSpeed = Humanoid.WalkSpeed
			OriginalJumpHeight = Humanoid.JumpHeight -- Usa JumpHeight agora
			Humanoid.WalkSpeed = 0
			Humanoid.JumpHeight = 0 -- Trava pulo
			Humanoid.JumpPower = 0 -- Garante trava em ambos modos
			IsStunned = true
		end

		-- Atualiza tempo de expira√ß√£o (para lidar com overlaps de stun)
		local myStunTime = tick() + data.Duration
		StunExpirationTime = math.max(StunExpirationTime, myStunTime)

		stunTrack:Play()
		print("üí´ [CombatController] STUNNED por", data.Duration, "segundos! Movimento e pulo travados.")

		-- Para stun ap√≥s dura√ß√£o
		task.delay(data.Duration, function()
			-- S√≥ restaura se o tempo atual j√° passou do tempo de expira√ß√£o do stun (evita bugs com stuns sobrepostos)
			if tick() >= StunExpirationTime - 0.1 then
				if stunTrack.IsPlaying then
					stunTrack:Stop(0.2)
				end

				if IsStunned then
					Humanoid.WalkSpeed = OriginalWalkSpeed
					Humanoid.JumpHeight = OriginalJumpHeight -- Restaura JumpHeight
					Humanoid.JumpPower = 50 -- Valor padr√£o ou restaurar se tivesse salvo
					IsStunned = false
					print("‚úÖ [CombatController] Stun terminado - Movimento restaurado")
				end
			end
		end)

	elseif action == "ParrySuccess" then
		-- Parry bem-sucedido! Toca som
		PlaySound("Parry")
		print("‚öîÔ∏è [CombatController] PARRY BEM-SUCEDIDO!")

	elseif action == "BlockSuccess" then
		-- Block bem-sucedido! (Som toca no servidor agora)
		print("üõ°Ô∏è [CombatController] BLOCK BEM-SUCEDIDO!")
		
	elseif action == "ForceStopBlock" then
		-- Postura quebrou, for√ßa parar de bloquear
		if IsBlocking then
			IsBlocking = false
			local blockTrack = LoadedAnims["Block"]
			if blockTrack and blockTrack.IsPlaying then
				blockTrack:Stop(0.1)
			end
			print("üí• [CombatController] For√ßado a parar de bloquear (Posture Break)")
		end
	end
end)

print("‚úÖ CombatController Iniciado com Sistema de Categorias ‚öîÔ∏è")
